// Database connection and schema definitions
export interface User {
  id: string
  email: string
  name: string
  role: string
  profileImage?: string
  createdAt: string
  updatedAt: string
}

export interface Bassin {
  id: string
  name: string
  location: string
  fishType: string
  capacity: string
  status: "excellent" | "good" | "warning" | "poor"
  description: string
  dateCreated: string
  userId: string
  isActive: boolean
}

export interface WaterQualityReading {
  id: string
  bassinId: string
  timestamp: string
  temperature: number
  turbidity: number
  dissolvedOxygen: number
  bod: number
  co2: number
  ph: number
  alkalinity: number
  hardness: number
  calcium: number
  ammonia: number
  nitrite: number
  phosphorus: number
  h2s: number
  plankton: number
  waterQuality: "Excellent" | "Good" | "Fair" | "Poor"
  status: string
  activeAlerts: number
  notes?: string
}

export interface Alert {
  id: string
  bassinId: string
  bassinName: string
  type: "danger" | "warning" | "info"
  category: "water_quality" | "system" | "maintenance" | "alert"
  title: string
  message: string
  timestamp: string
  isRead: boolean
  priority: "high" | "medium" | "low"
  parameters?: {
    parameter: string
    currentValue: number
    threshold: number
    unit: string
  }
  actionRequired: boolean
  autoGenerated: boolean
  userId: string
}

// Mock database - In production, use a real database like PostgreSQL, MySQL, or MongoDB
class MockDatabase {
  private users: User[] = [
    {
      id: "user-1",
      email: "admin@aquaculture.com",
      name: "John Doe",
      role: "Farm Manager",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: "user-2",
      email: "manager@aquaculture.com",
      name: "Jane Smith",
      role: "Operations Manager",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: "user-3",
      email: "operator@aquaculture.com",
      name: "Mike Johnson",
      role: "System Operator",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
  ]

  private bassins: Bassin[] = [
    {
      id: "bassin-1",
      name: "Bassin Alpha",
      location: "North Section",
      fishType: "Salmon",
      capacity: "50,000L",
      status: "excellent",
      description: "Primary salmon breeding bassin with advanced filtration system",
      dateCreated: "2024-01-15",
      userId: "user-1",
      isActive: true,
    },
    {
      id: "bassin-2",
      name: "Bassin Beta",
      location: "East Section",
      fishType: "Trout",
      capacity: "35,000L",
      status: "good",
      description: "Secondary trout cultivation bassin with temperature control",
      dateCreated: "2024-01-20",
      userId: "user-1",
      isActive: true,
    },
    {
      id: "bassin-3",
      name: "Bassin Gamma",
      location: "South Section",
      fishType: "Bass",
      capacity: "42,000L",
      status: "warning",
      description: "Bass breeding facility with automated feeding system",
      dateCreated: "2024-02-01",
      userId: "user-1",
      isActive: true,
    },
  ]

  private waterQualityReadings: WaterQualityReading[] = []
  private alerts: Alert[] = []

  // User methods
  async findUserByEmail(email: string): Promise<User | null> {
    return this.users.find((user) => user.email === email) || null
  }

  async findUserById(id: string): Promise<User | null> {
    return this.users.find((user) => user.id === id) || null
  }

  async updateUser(id: string, data: Partial<User>): Promise<User | null> {
    const userIndex = this.users.findIndex((user) => user.id === id)
    if (userIndex === -1) return null

    this.users[userIndex] = {
      ...this.users[userIndex],
      ...data,
      updatedAt: new Date().toISOString(),
    }
    return this.users[userIndex]
  }

  // Bassin methods
  async findBassinsByUserId(userId: string): Promise<Bassin[]> {
    return this.bassins.filter((bassin) => bassin.userId === userId && bassin.isActive)
  }

  async findBassinById(id: string): Promise<Bassin | null> {
    return this.bassins.find((bassin) => bassin.id === id && bassin.isActive) || null
  }

  async createBassin(data: Omit<Bassin, "id" | "dateCreated">): Promise<Bassin> {
    const newBassin: Bassin = {
      id: `bassin-${Date.now()}`,
      dateCreated: new Date().toISOString().split("T")[0],
      ...data,
    }
    this.bassins.push(newBassin)
    return newBassin
  }

  async updateBassin(id: string, data: Partial<Bassin>): Promise<Bassin | null> {
    const bassinIndex = this.bassins.findIndex((bassin) => bassin.id === id)
    if (bassinIndex === -1) return null

    this.bassins[bassinIndex] = {
      ...this.bassins[bassinIndex],
      ...data,
    }
    return this.bassins[bassinIndex]
  }

  async deleteBassin(id: string): Promise<boolean> {
    const bassinIndex = this.bassins.findIndex((bassin) => bassin.id === id)
    if (bassinIndex === -1) return false

    this.bassins[bassinIndex].isActive = false
    return true
  }

  // Water Quality methods
  async createWaterQualityReading(data: Omit<WaterQualityReading, "id" | "timestamp">): Promise<WaterQualityReading> {
    const newReading: WaterQualityReading = {
      id: `reading-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      ...data,
    }
    this.waterQualityReadings.push(newReading)

    // Keep only last 1000 readings per bassin
    const bassinReadings = this.waterQualityReadings.filter((r) => r.bassinId === data.bassinId)
    if (bassinReadings.length > 1000) {
      const toRemove = bassinReadings.slice(0, bassinReadings.length - 1000)
      this.waterQualityReadings = this.waterQualityReadings.filter((r) => !toRemove.includes(r))
    }

    return newReading
  }

  async findWaterQualityReadings(bassinId: string, limit?: number): Promise<WaterQualityReading[]> {
    const readings = this.waterQualityReadings
      .filter((reading) => reading.bassinId === bassinId)
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())

    return limit ? readings.slice(0, limit) : readings
  }

  async generateDummyWaterQualityData(bassinId: string, count = 50): Promise<void> {
    const dummyReadings: WaterQualityReading[] = []

    for (let i = 0; i < count; i++) {
      const timestamp = new Date(Date.now() - i * 60 * 60 * 1000) // Every hour going back

      // Generate realistic dummy data
      const temperature = 18 + Math.random() * 8 // 18-26Â°C
      const turbidity = 2 + Math.random() * 15 // 2-17 cm
      const dissolvedOxygen = 5 + Math.random() * 4 // 5-9 mg/L
      const bod = 1 + Math.random() * 8 // 1-9 mg/L
      const co2 = 5 + Math.random() * 15 // 5-20 mg/L
      const ph = 6.5 + Math.random() * 2 // 6.5-8.5
      const alkalinity = 80 + Math.random() * 120 // 80-200 mg/L
      const hardness = 100 + Math.random() * 200 // 100-300 mg/L
      const calcium = 20 + Math.random() * 80 // 20-100 mg/L
      const ammonia = 0.1 + Math.random() * 2 // 0.1-2.1 mg/L
      const nitrite = 0.05 + Math.random() * 1 // 0.05-1.05 mg/L
      const phosphorus = 0.5 + Math.random() * 3 // 0.5-3.5 mg/L
      const h2s = 0.01 + Math.random() * 0.5 // 0.01-0.51 mg/L
      const plankton = 1000 + Math.random() * 50000 // 1000-51000 No./L

      // Determine water quality based on parameters
      let waterQuality: "Excellent" | "Good" | "Fair" | "Poor" = "Excellent"
      if (temperature > 25 || ph < 6.8 || ph > 8.2 || dissolvedOxygen < 6 || ammonia > 1.5) {
        waterQuality = "Poor"
      } else if (temperature > 23 || ph < 7.0 || ph > 8.0 || dissolvedOxygen < 7 || ammonia > 1.0) {
        waterQuality = "Fair"
      } else if (temperature > 21 || dissolvedOxygen < 8 || ammonia > 0.5) {
        waterQuality = "Good"
      }

      const reading: WaterQualityReading = {
        id: `reading-dummy-${bassinId}-${i}`,
        bassinId,
        timestamp: timestamp.toISOString(),
        temperature,
        turbidity,
        dissolvedOxygen,
        bod,
        co2,
        ph,
        alkalinity,
        hardness,
        calcium,
        ammonia,
        nitrite,
        phosphorus,
        h2s,
        plankton,
        waterQuality,
        status: waterQuality.toLowerCase(),
        activeAlerts:
          waterQuality === "Poor"
            ? Math.floor(Math.random() * 4) + 1
            : waterQuality === "Fair"
              ? Math.floor(Math.random() * 2)
              : 0,
        notes: `Automated monitoring - ${waterQuality} conditions detected`,
      }

      dummyReadings.push(reading)
    }

    this.waterQualityReadings.push(...dummyReadings)
  }

  // Alert methods
  async createAlert(data: Omit<Alert, "id" | "timestamp">): Promise<Alert> {
    const newAlert: Alert = {
      id: `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      ...data,
    }
    this.alerts.push(newAlert)

    // Keep only last 100 alerts per user
    const userAlerts = this.alerts.filter((a) => a.userId === data.userId)
    if (userAlerts.length > 100) {
      const toRemove = userAlerts.slice(0, userAlerts.length - 100)
      this.alerts = this.alerts.filter((a) => !toRemove.includes(a))
    }

    return newAlert
  }

  async findAlertsByUserId(userId: string, limit?: number): Promise<Alert[]> {
    const alerts = this.alerts
      .filter((alert) => alert.userId === userId)
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())

    return limit ? alerts.slice(0, limit) : alerts
  }

  async updateAlert(id: string, data: Partial<Alert>): Promise<Alert | null> {
    const alertIndex = this.alerts.findIndex((alert) => alert.id === id)
    if (alertIndex === -1) return null

    this.alerts[alertIndex] = {
      ...this.alerts[alertIndex],
      ...data,
    }
    return this.alerts[alertIndex]
  }

  async deleteAlert(id: string): Promise<boolean> {
    const alertIndex = this.alerts.findIndex((alert) => alert.id === id)
    if (alertIndex === -1) return false

    this.alerts.splice(alertIndex, 1)
    return true
  }

  async clearAllAlerts(userId: string): Promise<void> {
    this.alerts = this.alerts.filter((alert) => alert.userId !== userId)
  }
}

export const db = new MockDatabase()
